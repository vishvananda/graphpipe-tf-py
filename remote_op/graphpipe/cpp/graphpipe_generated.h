// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_GRAPHPIPE_GRAPHPIPE_H_
#define FLATBUFFERS_GENERATED_GRAPHPIPE_GRAPHPIPE_H_

#include "flatbuffers/flatbuffers.h"

namespace graphpipe {

struct Tensor;
struct TensorBuilder;

struct Request;
struct RequestBuilder;

struct InferRequest;
struct InferRequestBuilder;

struct Error;
struct ErrorBuilder;

struct InferResponse;
struct InferResponseBuilder;

struct MetadataRequest;
struct MetadataRequestBuilder;

struct IOMetadata;
struct IOMetadataBuilder;

struct MetadataResponse;
struct MetadataResponseBuilder;

enum Type {
  Type_Null = 0,
  Type_Uint8 = 1,
  Type_Int8 = 2,
  Type_Uint16 = 3,
  Type_Int16 = 4,
  Type_Uint32 = 5,
  Type_Int32 = 6,
  Type_Uint64 = 7,
  Type_Int64 = 8,
  Type_Float16 = 9,
  Type_Float32 = 10,
  Type_Float64 = 11,
  Type_String = 12,
  Type_MIN = Type_Null,
  Type_MAX = Type_String
};

inline const Type (&EnumValuesType())[13] {
  static const Type values[] = {
    Type_Null,
    Type_Uint8,
    Type_Int8,
    Type_Uint16,
    Type_Int16,
    Type_Uint32,
    Type_Int32,
    Type_Uint64,
    Type_Int64,
    Type_Float16,
    Type_Float32,
    Type_Float64,
    Type_String
  };
  return values;
}

inline const char * const *EnumNamesType() {
  static const char * const names[14] = {
    "Null",
    "Uint8",
    "Int8",
    "Uint16",
    "Int16",
    "Uint32",
    "Int32",
    "Uint64",
    "Int64",
    "Float16",
    "Float32",
    "Float64",
    "String",
    nullptr
  };
  return names;
}

inline const char *EnumNameType(Type e) {
  if (flatbuffers::IsOutRange(e, Type_Null, Type_String)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesType()[index];
}

enum Req {
  Req_NONE = 0,
  Req_InferRequest = 1,
  Req_MetadataRequest = 2,
  Req_MIN = Req_NONE,
  Req_MAX = Req_MetadataRequest
};

inline const Req (&EnumValuesReq())[3] {
  static const Req values[] = {
    Req_NONE,
    Req_InferRequest,
    Req_MetadataRequest
  };
  return values;
}

inline const char * const *EnumNamesReq() {
  static const char * const names[4] = {
    "NONE",
    "InferRequest",
    "MetadataRequest",
    nullptr
  };
  return names;
}

inline const char *EnumNameReq(Req e) {
  if (flatbuffers::IsOutRange(e, Req_NONE, Req_MetadataRequest)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReq()[index];
}

template<typename T> struct ReqTraits {
  static const Req enum_value = Req_NONE;
};

template<> struct ReqTraits<graphpipe::InferRequest> {
  static const Req enum_value = Req_InferRequest;
};

template<> struct ReqTraits<graphpipe::MetadataRequest> {
  static const Req enum_value = Req_MetadataRequest;
};

bool VerifyReq(flatbuffers::Verifier &verifier, const void *obj, Req type);
bool VerifyReqVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef TensorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_SHAPE = 6,
    VT_DATA = 8,
    VT_STRING_VAL = 10
  };
  graphpipe::Type type() const {
    return static_cast<graphpipe::Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  const flatbuffers::Vector<int64_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SHAPE);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *string_val() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRING_VAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_STRING_VAL) &&
           verifier.VerifyVector(string_val()) &&
           verifier.VerifyVectorOfStrings(string_val()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  typedef Tensor Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(graphpipe::Type type) {
    fbb_.AddElement<uint8_t>(Tensor::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape) {
    fbb_.AddOffset(Tensor::VT_SHAPE, shape);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Tensor::VT_DATA, data);
  }
  void add_string_val(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> string_val) {
    fbb_.AddOffset(Tensor::VT_STRING_VAL, string_val);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    graphpipe::Type type = graphpipe::Type_Null,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> string_val = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_string_val(string_val);
  builder_.add_data(data);
  builder_.add_shape(shape);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    graphpipe::Type type = graphpipe::Type_Null,
    const std::vector<int64_t> *shape = nullptr,
    const std::vector<uint8_t> *data = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *string_val = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int64_t>(*shape) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  auto string_val__ = string_val ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*string_val) : 0;
  return graphpipe::CreateTensor(
      _fbb,
      type,
      shape__,
      data__,
      string_val__);
}

struct Request FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REQ_TYPE = 4,
    VT_REQ = 6
  };
  graphpipe::Req req_type() const {
    return static_cast<graphpipe::Req>(GetField<uint8_t>(VT_REQ_TYPE, 0));
  }
  const void *req() const {
    return GetPointer<const void *>(VT_REQ);
  }
  template<typename T> const T *req_as() const;
  const graphpipe::InferRequest *req_as_InferRequest() const {
    return req_type() == graphpipe::Req_InferRequest ? static_cast<const graphpipe::InferRequest *>(req()) : nullptr;
  }
  const graphpipe::MetadataRequest *req_as_MetadataRequest() const {
    return req_type() == graphpipe::Req_MetadataRequest ? static_cast<const graphpipe::MetadataRequest *>(req()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_REQ_TYPE) &&
           VerifyOffset(verifier, VT_REQ) &&
           VerifyReq(verifier, req(), req_type()) &&
           verifier.EndTable();
  }
};

template<> inline const graphpipe::InferRequest *Request::req_as<graphpipe::InferRequest>() const {
  return req_as_InferRequest();
}

template<> inline const graphpipe::MetadataRequest *Request::req_as<graphpipe::MetadataRequest>() const {
  return req_as_MetadataRequest();
}

struct RequestBuilder {
  typedef Request Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_req_type(graphpipe::Req req_type) {
    fbb_.AddElement<uint8_t>(Request::VT_REQ_TYPE, static_cast<uint8_t>(req_type), 0);
  }
  void add_req(flatbuffers::Offset<void> req) {
    fbb_.AddOffset(Request::VT_REQ, req);
  }
  explicit RequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RequestBuilder &operator=(const RequestBuilder &);
  flatbuffers::Offset<Request> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Request>(end);
    return o;
  }
};

inline flatbuffers::Offset<Request> CreateRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    graphpipe::Req req_type = graphpipe::Req_NONE,
    flatbuffers::Offset<void> req = 0) {
  RequestBuilder builder_(_fbb);
  builder_.add_req(req);
  builder_.add_req_type(req_type);
  return builder_.Finish();
}

struct InferRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InferRequestBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONFIG = 4,
    VT_INPUT_NAMES = 6,
    VT_INPUT_TENSORS = 8,
    VT_OUTPUT_NAMES = 10
  };
  const flatbuffers::String *config() const {
    return GetPointer<const flatbuffers::String *>(VT_CONFIG);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *input_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_INPUT_NAMES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<graphpipe::Tensor>> *input_tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<graphpipe::Tensor>> *>(VT_INPUT_TENSORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *output_names() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_OUTPUT_NAMES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONFIG) &&
           verifier.VerifyString(config()) &&
           VerifyOffset(verifier, VT_INPUT_NAMES) &&
           verifier.VerifyVector(input_names()) &&
           verifier.VerifyVectorOfStrings(input_names()) &&
           VerifyOffset(verifier, VT_INPUT_TENSORS) &&
           verifier.VerifyVector(input_tensors()) &&
           verifier.VerifyVectorOfTables(input_tensors()) &&
           VerifyOffset(verifier, VT_OUTPUT_NAMES) &&
           verifier.VerifyVector(output_names()) &&
           verifier.VerifyVectorOfStrings(output_names()) &&
           verifier.EndTable();
  }
};

struct InferRequestBuilder {
  typedef InferRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_config(flatbuffers::Offset<flatbuffers::String> config) {
    fbb_.AddOffset(InferRequest::VT_CONFIG, config);
  }
  void add_input_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input_names) {
    fbb_.AddOffset(InferRequest::VT_INPUT_NAMES, input_names);
  }
  void add_input_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<graphpipe::Tensor>>> input_tensors) {
    fbb_.AddOffset(InferRequest::VT_INPUT_TENSORS, input_tensors);
  }
  void add_output_names(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output_names) {
    fbb_.AddOffset(InferRequest::VT_OUTPUT_NAMES, output_names);
  }
  explicit InferRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InferRequestBuilder &operator=(const InferRequestBuilder &);
  flatbuffers::Offset<InferRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InferRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<InferRequest> CreateInferRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> config = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> input_names = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<graphpipe::Tensor>>> input_tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> output_names = 0) {
  InferRequestBuilder builder_(_fbb);
  builder_.add_output_names(output_names);
  builder_.add_input_tensors(input_tensors);
  builder_.add_input_names(input_names);
  builder_.add_config(config);
  return builder_.Finish();
}

inline flatbuffers::Offset<InferRequest> CreateInferRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *config = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *input_names = nullptr,
    const std::vector<flatbuffers::Offset<graphpipe::Tensor>> *input_tensors = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *output_names = nullptr) {
  auto config__ = config ? _fbb.CreateString(config) : 0;
  auto input_names__ = input_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*input_names) : 0;
  auto input_tensors__ = input_tensors ? _fbb.CreateVector<flatbuffers::Offset<graphpipe::Tensor>>(*input_tensors) : 0;
  auto output_names__ = output_names ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*output_names) : 0;
  return graphpipe::CreateInferRequest(
      _fbb,
      config__,
      input_names__,
      input_tensors__,
      output_names__);
}

struct Error FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ErrorBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CODE = 4,
    VT_MESSAGE = 6
  };
  int64_t code() const {
    return GetField<int64_t>(VT_CODE, 0);
  }
  const flatbuffers::String *message() const {
    return GetPointer<const flatbuffers::String *>(VT_MESSAGE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_MESSAGE) &&
           verifier.VerifyString(message()) &&
           verifier.EndTable();
  }
};

struct ErrorBuilder {
  typedef Error Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_code(int64_t code) {
    fbb_.AddElement<int64_t>(Error::VT_CODE, code, 0);
  }
  void add_message(flatbuffers::Offset<flatbuffers::String> message) {
    fbb_.AddOffset(Error::VT_MESSAGE, message);
  }
  explicit ErrorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ErrorBuilder &operator=(const ErrorBuilder &);
  flatbuffers::Offset<Error> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Error>(end);
    return o;
  }
};

inline flatbuffers::Offset<Error> CreateError(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t code = 0,
    flatbuffers::Offset<flatbuffers::String> message = 0) {
  ErrorBuilder builder_(_fbb);
  builder_.add_code(code);
  builder_.add_message(message);
  return builder_.Finish();
}

inline flatbuffers::Offset<Error> CreateErrorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t code = 0,
    const char *message = nullptr) {
  auto message__ = message ? _fbb.CreateString(message) : 0;
  return graphpipe::CreateError(
      _fbb,
      code,
      message__);
}

struct InferResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InferResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUT_TENSORS = 4,
    VT_ERRORS = 6
  };
  const flatbuffers::Vector<flatbuffers::Offset<graphpipe::Tensor>> *output_tensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<graphpipe::Tensor>> *>(VT_OUTPUT_TENSORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<graphpipe::Error>> *errors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<graphpipe::Error>> *>(VT_ERRORS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_OUTPUT_TENSORS) &&
           verifier.VerifyVector(output_tensors()) &&
           verifier.VerifyVectorOfTables(output_tensors()) &&
           VerifyOffset(verifier, VT_ERRORS) &&
           verifier.VerifyVector(errors()) &&
           verifier.VerifyVectorOfTables(errors()) &&
           verifier.EndTable();
  }
};

struct InferResponseBuilder {
  typedef InferResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_output_tensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<graphpipe::Tensor>>> output_tensors) {
    fbb_.AddOffset(InferResponse::VT_OUTPUT_TENSORS, output_tensors);
  }
  void add_errors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<graphpipe::Error>>> errors) {
    fbb_.AddOffset(InferResponse::VT_ERRORS, errors);
  }
  explicit InferResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InferResponseBuilder &operator=(const InferResponseBuilder &);
  flatbuffers::Offset<InferResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InferResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<InferResponse> CreateInferResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<graphpipe::Tensor>>> output_tensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<graphpipe::Error>>> errors = 0) {
  InferResponseBuilder builder_(_fbb);
  builder_.add_errors(errors);
  builder_.add_output_tensors(output_tensors);
  return builder_.Finish();
}

inline flatbuffers::Offset<InferResponse> CreateInferResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<graphpipe::Tensor>> *output_tensors = nullptr,
    const std::vector<flatbuffers::Offset<graphpipe::Error>> *errors = nullptr) {
  auto output_tensors__ = output_tensors ? _fbb.CreateVector<flatbuffers::Offset<graphpipe::Tensor>>(*output_tensors) : 0;
  auto errors__ = errors ? _fbb.CreateVector<flatbuffers::Offset<graphpipe::Error>>(*errors) : 0;
  return graphpipe::CreateInferResponse(
      _fbb,
      output_tensors__,
      errors__);
}

struct MetadataRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetadataRequestBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MetadataRequestBuilder {
  typedef MetadataRequest Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MetadataRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetadataRequestBuilder &operator=(const MetadataRequestBuilder &);
  flatbuffers::Offset<MetadataRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MetadataRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<MetadataRequest> CreateMetadataRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MetadataRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct IOMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IOMetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_DESCRIPTION = 6,
    VT_SHAPE = 8,
    VT_TYPE = 10
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::Vector<int64_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SHAPE);
  }
  graphpipe::Type type() const {
    return static_cast<graphpipe::Type>(GetField<uint8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           VerifyField<uint8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct IOMetadataBuilder {
  typedef IOMetadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(IOMetadata::VT_NAME, name);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(IOMetadata::VT_DESCRIPTION, description);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape) {
    fbb_.AddOffset(IOMetadata::VT_SHAPE, shape);
  }
  void add_type(graphpipe::Type type) {
    fbb_.AddElement<uint8_t>(IOMetadata::VT_TYPE, static_cast<uint8_t>(type), 0);
  }
  explicit IOMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IOMetadataBuilder &operator=(const IOMetadataBuilder &);
  flatbuffers::Offset<IOMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IOMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<IOMetadata> CreateIOMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape = 0,
    graphpipe::Type type = graphpipe::Type_Null) {
  IOMetadataBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_description(description);
  builder_.add_name(name);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<IOMetadata> CreateIOMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *description = nullptr,
    const std::vector<int64_t> *shape = nullptr,
    graphpipe::Type type = graphpipe::Type_Null) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto shape__ = shape ? _fbb.CreateVector<int64_t>(*shape) : 0;
  return graphpipe::CreateIOMetadata(
      _fbb,
      name__,
      description__,
      shape__,
      type);
}

struct MetadataResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetadataResponseBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERSION = 6,
    VT_SERVER = 8,
    VT_DESCRIPTION = 10,
    VT_INPUTS = 12,
    VT_OUTPUTS = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  const flatbuffers::String *server() const {
    return GetPointer<const flatbuffers::String *>(VT_SERVER);
  }
  const flatbuffers::String *description() const {
    return GetPointer<const flatbuffers::String *>(VT_DESCRIPTION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<graphpipe::IOMetadata>> *inputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<graphpipe::IOMetadata>> *>(VT_INPUTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<graphpipe::IOMetadata>> *outputs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<graphpipe::IOMetadata>> *>(VT_OUTPUTS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyOffset(verifier, VT_SERVER) &&
           verifier.VerifyString(server()) &&
           VerifyOffset(verifier, VT_DESCRIPTION) &&
           verifier.VerifyString(description()) &&
           VerifyOffset(verifier, VT_INPUTS) &&
           verifier.VerifyVector(inputs()) &&
           verifier.VerifyVectorOfTables(inputs()) &&
           VerifyOffset(verifier, VT_OUTPUTS) &&
           verifier.VerifyVector(outputs()) &&
           verifier.VerifyVectorOfTables(outputs()) &&
           verifier.EndTable();
  }
};

struct MetadataResponseBuilder {
  typedef MetadataResponse Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MetadataResponse::VT_NAME, name);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(MetadataResponse::VT_VERSION, version);
  }
  void add_server(flatbuffers::Offset<flatbuffers::String> server) {
    fbb_.AddOffset(MetadataResponse::VT_SERVER, server);
  }
  void add_description(flatbuffers::Offset<flatbuffers::String> description) {
    fbb_.AddOffset(MetadataResponse::VT_DESCRIPTION, description);
  }
  void add_inputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<graphpipe::IOMetadata>>> inputs) {
    fbb_.AddOffset(MetadataResponse::VT_INPUTS, inputs);
  }
  void add_outputs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<graphpipe::IOMetadata>>> outputs) {
    fbb_.AddOffset(MetadataResponse::VT_OUTPUTS, outputs);
  }
  explicit MetadataResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetadataResponseBuilder &operator=(const MetadataResponseBuilder &);
  flatbuffers::Offset<MetadataResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MetadataResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<MetadataResponse> CreateMetadataResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<flatbuffers::String> server = 0,
    flatbuffers::Offset<flatbuffers::String> description = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<graphpipe::IOMetadata>>> inputs = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<graphpipe::IOMetadata>>> outputs = 0) {
  MetadataResponseBuilder builder_(_fbb);
  builder_.add_outputs(outputs);
  builder_.add_inputs(inputs);
  builder_.add_description(description);
  builder_.add_server(server);
  builder_.add_version(version);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MetadataResponse> CreateMetadataResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *version = nullptr,
    const char *server = nullptr,
    const char *description = nullptr,
    const std::vector<flatbuffers::Offset<graphpipe::IOMetadata>> *inputs = nullptr,
    const std::vector<flatbuffers::Offset<graphpipe::IOMetadata>> *outputs = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto server__ = server ? _fbb.CreateString(server) : 0;
  auto description__ = description ? _fbb.CreateString(description) : 0;
  auto inputs__ = inputs ? _fbb.CreateVector<flatbuffers::Offset<graphpipe::IOMetadata>>(*inputs) : 0;
  auto outputs__ = outputs ? _fbb.CreateVector<flatbuffers::Offset<graphpipe::IOMetadata>>(*outputs) : 0;
  return graphpipe::CreateMetadataResponse(
      _fbb,
      name__,
      version__,
      server__,
      description__,
      inputs__,
      outputs__);
}

inline bool VerifyReq(flatbuffers::Verifier &verifier, const void *obj, Req type) {
  switch (type) {
    case Req_NONE: {
      return true;
    }
    case Req_InferRequest: {
      auto ptr = reinterpret_cast<const graphpipe::InferRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Req_MetadataRequest: {
      auto ptr = reinterpret_cast<const graphpipe::MetadataRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyReqVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyReq(
        verifier,  values->Get(i), types->GetEnum<Req>(i))) {
      return false;
    }
  }
  return true;
}

inline const graphpipe::Request *GetRequest(const void *buf) {
  return flatbuffers::GetRoot<graphpipe::Request>(buf);
}

inline const graphpipe::Request *GetSizePrefixedRequest(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<graphpipe::Request>(buf);
}

inline bool VerifyRequestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<graphpipe::Request>(nullptr);
}

inline bool VerifySizePrefixedRequestBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<graphpipe::Request>(nullptr);
}

inline void FinishRequestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<graphpipe::Request> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRequestBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<graphpipe::Request> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace graphpipe

#endif  // FLATBUFFERS_GENERATED_GRAPHPIPE_GRAPHPIPE_H_
